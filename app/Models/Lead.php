<?php
declare(strict_types=1);

namespace App\Models;

use App\Events\Lead\{
    LeadChangedSubstatus, LeadIntegrated, LeadApproved, LeadCancelled, LeadCreated, LeadReverted, LeadTrashed
};
use App\Services\LeadStateService;
use Hashids;
use Carbon\Carbon;
use Illuminate\Database\Eloquent\Builder;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use App\Models\Scopes\IsTestScope;
use App\Models\Traits\EloquentHashids;
use Illuminate\Database\Eloquent\SoftDeletes;
use App\Models\Traits\DynamicHiddenVisibleTrait;
use App\Exceptions\Hashids\NotDecodedHashException;

/**
 * @todo Add GlobalUserEnabled scope
 * @method $this wherePublisherIds(array $publisher_ids)
 * @method $this whereAdvertiser($user_role, $user_id, ?array $advertiser_hashes = [])
 * @method $this wherePublisher($user_id, $user_role, ?array $publisher_hashes = [])
 * @method $this whereIntegration(Integration $integration)
 * @method $this whereIntegrated(boolean $is_integrated = true)
 * @method $this whereCurrencies(array $currency_ids = [])
 * @method $this whereAdvertiserCurrencies(array $currency_ids = [])
 * @method $this whereOffer(array $offer_hashes = [])
 * @method $this whereTargets(array $offer_hashes = [])
 * @method $this whereCountries(array $country_ids = [])
 * @method $this whereDeviceType(array $device_type_ids = [])
 * @method $this whereOsPlatform(array $os_platform_ids = [])
 * @method $this whereBrowser(array $browser_ids = [])
 * @method $this search(?string $search_field, ?string $search)
 * @method $this uncompleted()
 * @method $this approved()
 * @property Advertiser advertiser
 * @property User publisher
 * @property Target target
 */
class Lead extends AbstractEntity
{
    use SoftDeletes;
    use EloquentHashids;
    use DynamicHiddenVisibleTrait;

    public const COD_TYPE = 'cod';
    public const INTEGRATION = 'integration';

    public const WEB_ORIGIN = 'web';
    public const API_ORIGIN = 'api';

    public const NEW = 'new';
    public const APPROVED = 'approved';
    public const CANCELLED = 'cancelled';
    public const TRASHED = 'trashed';
    public const FACEBOOK_BROWSER = 'facebook';
    public const INSTAGRAM_BROWSER = 'instagram';
    public const DEFAULT_BROWSER = 'default';

    public const INCORRECT_DATA_SUBSTATUS_ID = 4;
    public const DUBL_SUBSTATUS_ID = 5;
    public const INCORRECT_GEO_SUBSTATUS_ID = 6;
    public const PURCHASED_SUBSTATUS_ID = 21;
    public const APPROVED_THEN_CANCELLED_SUBSTATUS_ID = 22;
    public const UNDELIVERED_SUBSTATUS_ID = 23;
    public const PAID_SUBSTATUS_ID = 25;
    public const CALL_LATER_SUBSTATUS_ID = 28;
    public const CLOSED_SUBSTATUS_ID = 30;
    public const INACTIVE_OFFER_SUBSTATUS_ID = 31;

    protected $guarded = ['id', 'hash'];
    protected $hidden = [
        'id', 'domain_id', 'offer_id', 'target_id', 'target_geo_rule_id', 'target_geo_id', 'publisher_id',
        'advertiser_id', 'landing_id', 'transit_id', 'locale_id', 'flow_id', 'order_id', 'profit', 'hourly_stat_id',
        'device_stat_id', 'deleted_at', 'updated_at', 'is_integrated', 'integration_id', 'payment_method_id',
        'origin_lead_id', 's_id', 'advertiser_payout', 'advertiser_currency_id', 'advertiser_payout_completed_at',
        'origin_lead_hash', 'is_test', 'is_autogenerated', 'lorem_ipsuma_version', 'click_id',
    ];
    public $advertiser_hidden = [
        'id', 'domain_id', 'offer_id', 'target_id', 'target_geo_rule_id', 'target_geo_id', 'publisher_id',
        'advertiser_id', 'landing_id', 'transit_id', 'locale_id', 'flow_id', 'order_id', 'deleted_at', 'updated_at',
        'is_integrated', 'integration_id', 'payment_method_id', 'origin_lead_id', 's_id',
        'origin_lead_hash', 'is_test', 'is_autogenerated', 'hourly_stat_id', 'device_stat_id', 'target_geo_stat_id', 'lorem_ipsuma_version',
        'payout', 'profit', 'click_id', 'hold_at',
    ];
    protected $dates = ['initialized_at', 'deleted_at', 'processed_at'];
    protected $appends = ['origin_lead_hash'];

    protected static function boot()
    {
        parent::boot();

        static::addGlobalScope(new IsTestScope);
    }

    public function setIpCountryIdAttribute($value)
    {
        $this->attributes['ip_country_id'] = $value ?: $this->attributes['country_id'];
    }

    public function getOriginLeadHashAttribute()
    {
        if (isset($this->attributes['origin_lead_id']) && $this->attributes['origin_lead_id'] > 0) {
            return Hashids::encode($this->attributes['origin_lead_id']);
        }
    }

    public function integration()
    {
        return $this->morphTo();
    }

    public function country(): BelongsTo
    {
        return $this->belongsTo(Country::class);
    }

    public function ip_country(): BelongsTo
    {
        return $this->belongsTo(Country::class, 'ip_country_id');
    }

    public function order(): BelongsTo
    {
        return $this->belongsTo(Order::class);
    }

    public function locale(): BelongsTo
    {
        return $this->belongsTo(Locale::class);
    }

    public function flow(): BelongsTo
    {
        return $this->belongsTo(Flow::class);
    }

    public function city(): BelongsTo
    {
        return $this->belongsTo(City::class);
    }

    public function offer(): BelongsTo
    {
        return $this->belongsTo(Offer::class);
    }

    public function landing(): BelongsTo
    {
        return $this->belongsTo(Landing::class);
    }

    public function transit(): BelongsTo
    {
        return $this->belongsTo(Transit::class);
    }

    public function target(): BelongsTo
    {
        return $this->belongsTo(Target::class);
    }

    public function target_geo(): BelongsTo
    {
        return $this->belongsTo(TargetGeo::class);
    }

    public function target_geo_rule(): BelongsTo
    {
        return $this->belongsTo(TargetGeoRule::class);
    }

    public function currency(): BelongsTo
    {
        return $this->belongsTo(Currency::class);
    }

    public function advertiser_currency(): BelongsTo
    {
        return $this->belongsTo(Currency::class, 'advertiser_currency_id');
    }

    public function publisher(): BelongsTo
    {
        return $this->belongsTo(User::class, 'publisher_id', 'id');
    }

    public function advertiser(): BelongsTo
    {
        return $this->belongsTo(Advertiser::class, 'advertiser_id', 'id');
    }

    public function postbackin_logs(): HasMany
    {
        return $this->hasMany(PostbackinLog::class);
    }

    public function status_log(): HasMany
    {
        return $this->hasMany(LeadStatusLog::class);
    }

    public function balance_transactions(): HasMany
    {
        return $this->hasMany(BalanceTransaction::class, 'entity_id');
    }

    public function domain(): BelongsTo
    {
        return $this->belongsTo(Domain::class);
    }

    public function integrated()
    {
        return $this->getAttribute('is_integrated') === 1;
    }

    public function cannotIntegrate()
    {
        return $this->integrated() || !$this->isNew();
    }

    public function scopeWhereCurrencies(Builder $builder, array $currency_ids = [])
    {
        if (!\count($currency_ids)) {
            return $builder;
        }

        return $builder->whereIn('currency_id', $currency_ids);
    }

    public function scopeWhereAdvertiserCurrencies(Builder $builder, $currency_ids = [])
    {
        if (!\count($currency_ids)) {
            return $builder;
        }

        return $builder->whereIn('advertiser_currency_id', $currency_ids);
    }

    public function scopeApproved(Builder $query)
    {
        return $query->where('status', 'approved');
    }

    public function scopeWherePublisher(Builder $query, int $user_id, $user_role, $publisher_hashes = [])
    {
        switch ($user_role) {
            case 'administrator':
            case 'advertiser':
                if (\count($publisher_hashes) > 0) {
                    $query->whereIn('leads.publisher_id', getIdsByHashes($publisher_hashes));
                }
                break;

            case 'publisher':
                $query->where('leads.publisher_id', $user_id);
                break;
        }

        return $query;
    }

    public function scopeWherePublisherIds(Builder $query, $publisher_ids = [])
    {
        if (\is_array($publisher_ids) && \count($publisher_ids) > 0) {
            $query->whereIn('leads.publisher_id', $publisher_ids);
        }

        return $query;
    }

    public function scopeWithoutFallbackPublisher(Builder $query)
    {
        return $query->where('leads.publisher_id', '!=', (int)config('env.fallback_publisher_id'));
    }

    public function scopeWhereIntegration(Builder $query, Integration $integration)
    {
        if (!$integration instanceof Integration) {
            throw new \LogicException('Incorrect lead integration type');
        }
        $integration_type = self::INTEGRATION;

        return $query
            ->where('integration_id', $integration['id'])
            ->where('integration_type', $integration_type);
    }

    public function scopeWhereAdvertiser(Builder $query, $user_role, $user_id, ?array $advertiser_hashes = [])
    {
        if ($user_role === 'administrator' && \count($advertiser_hashes) > 0) {
            $query->whereIn('leads.advertiser_id', getIdsByHashes($advertiser_hashes));

        } elseif ($user_role === 'advertiser') {
            $query->where('leads.advertiser_id', $user_id);
        }

        return $query;
    }

    public function scopeWhereAdvertiserIds(Builder $query, ?array $advertiser_ids = [])
    {
        if (is_array($advertiser_ids) && count($advertiser_ids) > 0) {
            $query->whereIn('leads.advertiser_id', $advertiser_ids);
        }

        return $query;
    }

    public function scopeWhereStatus(Builder $query, $lead_statuses)
    {
        if (is_array($lead_statuses) && count($lead_statuses) > 0) {
            $query->whereIn('leads.status', $lead_statuses);
        }

        return $query;
    }

    public function scopeWhereExternalKey(Builder $query, $external_keys)
    {
        if (is_array($external_keys) && count($external_keys) > 0) {
            $query->whereIn('leads.external_key', $external_keys);
        }

        return $query;
    }

    public function scopeWhereFlow(Builder $query, $flows_hashes)
    {
        if (\is_array($flows_hashes) && \count($flows_hashes) > 0) {
            $query->whereIn('leads.flow_id', getIdsByHashes($flows_hashes));
        }
        return $query;
    }

    public function scopeWhereOffer(Builder $query, $offers_hashes)
    {
        if (\is_array($offers_hashes) && \count($offers_hashes) > 0) {
            $query->whereIn('leads.offer_id', getIdsByHashes($offers_hashes));
        }
        return $query;
    }

    public function scopeWhereOfferIds(Builder $query, $offers_ids = [])
    {
        if (\is_array($offers_ids) && \count($offers_ids) > 0) {
            $query->whereIn('leads.offer_id', $offers_ids);
        }

        return $query;
    }

    public function scopeWhereTargets(Builder $query, $target_hashes = [])
    {
        if (\is_array($target_hashes) && \count($target_hashes) > 0) {
            $query->whereIn('leads.target_id', array_map(function ($hash) {
                return Hashids::decode($hash)[0];
            }, $target_hashes));
        }

        return $query;
    }

    public function scopeWhereLanding(Builder $query, $landing_hashes = [])
    {
        if (\is_array($landing_hashes) && \count($landing_hashes) > 0) {
            $query->whereIn('leads.landing_id', getIdsByHashes($landing_hashes));
        }
        return $query;
    }

    public function scopeWhereTransits(Builder $query, $transit_hashes = [])
    {
        if (\is_array($transit_hashes) && \count($transit_hashes) > 0) {

            $query->whereIn('leads.transit_id',
                collect(array_map(function ($hash) {
                        return Hashids::decode($hash)[0] ?? 0;
                    }, $transit_hashes)
                )->reject(function ($value) {
                    return \is_null($value);
                })
            );
        }

        return $query;
    }

    /**
     * Фильтрация по странце гео цели
     *
     * @param Builder $query
     * @param array $country_ids
     * @return Builder
     */
    public function scopeWhereCountries(Builder $query, $country_ids = [])
    {
        if (\count($country_ids) > 0) {
            $query->whereIn('leads.country_id', $country_ids);
        }

        return $query;
    }

    public function scopeWhereIpCountries(Builder $query, $country_ids = [])
    {
        if (\count($country_ids) > 0) {
            $query->whereIn('leads.ip_country_id', $country_ids);
        }

        return $query;
    }

    public function scopeWhereRegion(Builder $builder, $region_id)
    {
        return $builder->when($region_id, function (Builder $builder) use ($region_id) {
            return $builder->where('region_id', $region_id);
        });
    }

    public function scopeWhereHour(Builder $builder, $hour)
    {
        return $builder->createdAtHour($hour);
    }

    public function scopeWhereCity(Builder $builder, $city_id)
    {
        return $builder->when($city_id, function (Builder $builder) use ($city_id) {
            return $builder->where('city_id', $city_id);
        });
    }

    public function scopeWhereData1(Builder $query, $data1_list)
    {
        if (\is_array($data1_list) && \count($data1_list) > 0) {
            $query->whereIn('leads.data1', $data1_list);
        }

        return $query;
    }

    public function scopeWhereData2(Builder $query, $data2_list)
    {
        if (is_array($data2_list) && count($data2_list) > 0) {
            $query->whereIn('leads.data2', $data2_list);
        }

        return $query;
    }

    public function scopeWhereData3(Builder $query, $data3_list)
    {
        if (is_array($data3_list) && count($data3_list) > 0) {
            $query->whereIn('leads.data3', $data3_list);
        }

        return $query;
    }

    public function scopeWhereData4(Builder $query, $data4_list)
    {
        if (is_array($data4_list) && count($data4_list) > 0) {
            $query->whereIn('leads.data4', $data4_list);
        }

        return $query;
    }

    public function scopeWhereBrowser(Builder $query, $browser_ids)
    {
        if (is_array($browser_ids) && count($browser_ids) > 0) {
            $query->whereIn('leads.browser_id', $browser_ids);
        }

        return $query;
    }

    public function scopeWhereDeviceType(Builder $query, $device_type_ids)
    {
        if (is_array($device_type_ids) && count($device_type_ids) > 0) {
            $query->whereIn('leads.device_type_id', $device_type_ids);
        }

        return $query;
    }

    public function scopeWhereOsPlatform(Builder $query, $os_platform_ids)
    {
        if (is_array($os_platform_ids) && count($os_platform_ids) > 0) {
            $query->whereIn('leads.os_platform_id', $os_platform_ids);
        }

        return $query;
    }

    /**
     * @todo rename it to whereHashes
     */
    public function scopeWhereHash(Builder $query, $hashes)
    {
        if (is_array($hashes) && count($hashes) > 0) {
            $query->whereIn('leads.hash', $hashes);
        }

        return $query;
    }

    public function scopeWithTest(Builder $query)
    {
        return $query->withoutGlobalScopes([IsTestScope::class]);
    }

    public function scopeSearch(Builder $builder, ?string $search_field, ?string $search)
    {
        // @todo remove
        if (is_null($search)) {
            $search = '';
        }

        $search = trim(urldecode($search));

        if (empty($search_field) || empty($search)) {
            return $builder;
        }

        switch ($search_field) {
            case 'id':
                return $builder->whereIn('id', explode(',', $search));

            case 'publisher_hash':
                $publisher_id = Hashids::decode($search)[0] ?? -1;
                return $builder->where('publisher_id', $publisher_id);

            case 'flow_hash':
                $flow_id = Hashids::decode($search)[0] ?? -1;
                return $builder->where('flow_id', $flow_id);

            case 'hash':
                $ids = [];
                $hashes = explode(',', $search);
                foreach ($hashes as $hash) {
                    try {
                        $ids[] = $this->getIdFromHash($hash);
                    } catch (NotDecodedHashException $e) {
                        continue;
                    }
                }
                return $builder->whereIn('id', $ids);

            case 'phone':
                if (!starts_with($search, '+')) {
                    $search = "+{$search}";
                }
                return $builder->whereHas('order', function ($builder) use ($search) {
                    return $builder->where('phone', $search);
                });

            case 'name':
                return $builder->whereHas('order', function ($builder) use ($search) {
                    return $builder->where('name', $search);
                });
        }
    }

    public function scopeWhereIsAutogenerated(Builder $builder, $is_autogenerated)
    {
        if (is_null($is_autogenerated)) {
            return $builder;
        }

        return $builder->where('is_autogenerated', $is_autogenerated);
    }

    public function scopeNew(Builder $builder)
    {
        return $builder->where('status', self::NEW);
    }

    public function scopeWhereIntegrated(Builder $builder, bool $is_integrated = true)
    {
        return $builder->where('is_integrated', (int)$is_integrated);
    }

    public function scopeUncompleted(Builder $builder)
    {
        return $builder->whereNull('advertiser_payout_completed_at');
    }

    public function createNew(array $params): self
    {
        $publisher = User::find($params['publisher_id']);

        $offer = Offer::isActiveForPublisher($publisher)
            ->where('id', $params['offer_id'])
            ->first();

        $should_trash = !$publisher->isFallbackPublisher() && $offer->isInactiveForPublisher();

        if ($should_trash) {
            $params = array_merge($params, [
                'advertiser_payout' => 0,
                'payout' => 0,
                'profit' => 0,
                'advertiser_id' => config('env.fallback_advertiser_id'),
                'advertiser_currency_id' => Currency::USD_ID,
            ]);
        }

        $lead = self::create($params);

        event(new LeadCreated($lead, PostbackOut::LEAD_ADD));

        if ($should_trash) {
            $lead->trash(Lead::INACTIVE_OFFER_SUBSTATUS_ID);
        }

        return $lead;
    }

    /**
     * Генерация случайного значение для external_key
     *
     * @return int
     */
    public function generateExternalKeyById(): int
    {
        while (true) {
            $external_key = crc32((string)(time() + $this->attributes['id']));
            if (null === self::where('external_key', $external_key)->first()) {
                return $external_key;
            }
        }
    }

    public function integrateCod(Integration $integration, TargetGeoRule $rule)
    {
        $this->update([
            'integration_id' => $integration['id'],
            'integration_type' => self::INTEGRATION,
            'advertiser_id' => $rule['advertiser_id'],
            'target_geo_rule_id' => $rule['id'],
            'advertiser_payout' => $rule['charge'],
            'advertiser_currency_id' => $rule['currency_id'],
        ]);

        return $this;
    }

    /**
     * Установка лиду признака интегрированности
     *
     * @param $external_key
     *
     * @return Lead
     */
    public function setAsIntegrated($external_key): Lead
    {
        LeadStateService::validateIntegratedState($this);

        $this->update([
            'external_key' => $external_key,
            'is_integrated' => 1
        ]);

        event(new LeadIntegrated($this));

        return $this;
    }

    public function approve(int $sub_status_id = 0, string $sub_status = '', Carbon $processed_at = null): self
    {
        LeadStateService::validateApproveState($this);

        if (\is_null($processed_at)) {
            $processed_at = Carbon::now()->toDateTimeString();
        } else {
            $processed_at = $processed_at->toDateTimeString();
        }

        $from_status = $this['status'];

        $target_geo = (new TargetGeo())->getById((int)$this['target_geo_id'], [], (int)$this['publisher_id']);

        $hold_at = Carbon::createFromFormat('Y-m-d H:i:s', $processed_at)->addMinutes($target_geo['hold_time']);

        $this->update([
            'status' => self::APPROVED,
            'is_hold' => 1,
            'processed_at' => $processed_at,
            'hold_time' => $target_geo['hold_time'],
            'hold_at' => $hold_at,
            'sub_status_id' => $sub_status_id,
            'sub_status' => $sub_status
        ]);

        event(new LeadApproved($this, $from_status));

        return $this;
    }

    public function approveIfNotAproved(int $sub_status_id = 0, string $sub_status = '')
    {
        if (!$this->isApproved()) {
            $this->approve($sub_status_id, $sub_status);
        }

        return $this;
    }

    public function changeSubstatus(int $sub_status_id, string $sub_status = '', ?string $foreign_changed_at = null): Lead
    {
        $this->update([
            'sub_status_id' => $sub_status_id,
            'sub_status' => $sub_status
        ]);

        event(new LeadChangedSubstatus($this, $foreign_changed_at));

        return $this;

    }

    public function cancelIfNotCancelled(int $sub_status_id = 0, string $sub_status = '')
    {
        if (!$this->isCancelled()) {
            $this->cancel($sub_status_id, $sub_status);
        }

        return $this;
    }

    public function cancel(int $sub_status_id = 0, string $sub_status = '', Carbon $processed_at = null): self
    {
        LeadStateService::validateCancelState($this);

        if (\is_null($processed_at)) {
            $processed_at = Carbon::now()->toDateTimeString();
        } else {
            $processed_at = $processed_at->toDateTimeString();
        }

        $from_status = $this['status'];

        $this->update([
            'status' => self::CANCELLED,
            'sub_status_id' => $sub_status_id,
            'sub_status' => $sub_status,
            'processed_at' => $processed_at,
        ]);

        event(new LeadCancelled($this, $from_status));

        return $this;
    }

    public function trashIfNotTrashed(int $sub_status_id = 0, string $sub_status = '')
    {
        if (!$this->isTrashed()) {
            $this->trash($sub_status_id, $sub_status);
        }

        return $this;
    }

    public function trash(int $sub_status_id = 0, string $sub_status = '', Carbon $processed_at = null): self
    {
        LeadStateService::validateTrashState($this);

        if (\is_null($processed_at)) {
            $processed_at = Carbon::now()->toDateTimeString();
        } else {
            $processed_at = $processed_at->toDateTimeString();
        }

        $from_status = $this['status'];

        $this->update([
            'status' => self::TRASHED,
            'sub_status_id' => $sub_status_id,
            'sub_status' => $sub_status,
            'processed_at' => $processed_at,
        ]);

        event(new LeadTrashed($this, $from_status));

        return $this;
    }

    public function revert(): self
    {
        $from_status = $this['status'];

        $this->update([
            'integration_id' => 0,
            'is_integrated' => 0,
            'external_key' => '',
            'status' => self::NEW,
            'sub_status_id' => 0,
            'processed_at' => null,
        ]);

        event(new LeadReverted($this, $from_status));

        return $this;
    }

    public function unhold()
    {
        $this->update([
            'is_hold' => 0,
        ]);
    }

    public function getById(int $id, array $relations = array()): self
    {
        return self::with($relations)->findOrFail($id);
    }

    public function getByByHash(string $hash, array $relations = []): self
    {
        $id = $this->getIdFromHash($hash);

        return $this->getById($id, $relations);
    }

    public function getByExternalKey(int $integration_id, $external_key, array $relations = []): self
    {
        return self::with($relations)
            ->where('integration_id', $integration_id)
            ->where('external_key', $external_key)
            ->firstOrFail();
    }

    /**
     * Получение идентификатора потока по его hash
     *
     * @param string $lead_hash
     * @return mixed
     * @throws NotDecodedHashException
     */
    public function getIdFromHash(string $lead_hash): int
    {
        $decoded_data = Hashids::decode($lead_hash);
        if (count($decoded_data) < 1) {
            throw new NotDecodedHashException('Incorrect lead hash [' . $lead_hash . ']');
        }

        return (int)$decoded_data[0];
    }

    public function onHold(): bool
    {
        return (bool)$this->is_hold;
    }

    public function isNew()
    {
        return $this->status === self::NEW;
    }

    public function isApproved()
    {
        return $this->status === self::APPROVED;
    }

    public function isTrashed()
    {
        return $this->status === self::TRASHED;
    }

    public function isCancelled()
    {
        return $this->status === self::CANCELLED;
    }

    /**
     * Получение типа перехода на лендинг с прелендинга
     *
     * @return string
     */
    public static function getTransitTrafficType($from): string
    {
        switch ($from) {
            case 'transit':
                return 'click';

            case 'noback':
                return 'noback';

            case 'comeback':
                return 'comeback';

            default:
                return '';
        }
    }

    public function complete(float $profit, Carbon $competed_at = null)
    {
        if (\is_null($competed_at)) {
            $competed_at = $this['processed_at'];
        } else {
            $competed_at = $competed_at->toDateTimeString();
        }

        $this->update([
            'advertiser_payout_completed_at' => $competed_at,
            'profit' => $profit,
        ]);

        return $this;
    }

    public function completed()
    {
        return !\is_null($this['advertiser_payout_completed_at']);
    }

    public static function existsByClickId(int $click_id): bool
    {
        return self::where('click_id', $click_id)->exists();
    }
}
